<html><h3>Pattern ID :6281
</h3><img src='21714955.png'><BR><BR><BR><link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
        feature_dict = self.tokenizer([[self.input_text, p_text]], return_tensors=&quotpt&quot, add_special_tokens=False).to(
            self.model.device)
        prediction = self.model(**feature_dict, output_hidden_states=True)
        outputs = prediction.decoder_hidden_states[-1].squeeze(0)<a id="change"> if </a>&quotdecoder_hidden_states&quot in prediction<a id="change"> else </a>prediction.hidden_states[-1].squeeze(0)
        return outputs.data[-1]

    def _predict(self, vocab_id):</code></pre><h3>After Change</h3><pre><code class='java'>

    def _get_obs(self, predicted=[]):
        p_text = self.tokenizer.convert_tokens_to_string(predicted)
        <a id="change">if </a><a id="change">hasattr(</a>self.model.model, <a id="change">&quotdecoder&quot</a><a id="change">)</a>:
            feature_dict = self.tokenizer([self.input_text], return_tensors=&quotpt&quot, add_special_tokens=False).to(
                self.model.device)
            predicted = [self.tokenizer.eos_token] + predicted
            dec_input<a id="change"> = </a>torch.tensor([self.tokenizer.convert_tokens_to_ids(predicted)]).to(self.model.device)
            feature_dict[&quotdecoder_input_ids&quot] = dec_input
            prediction<a id="change"> = </a>self.model(**feature_dict, output_hidden_states=True)
            outputs = prediction.decoder_hidden_states[-1].squeeze(0)
        else:
            feature_dict = self.tokenizer([[self.input_text, p_text]], return_tensors=&quotpt&quot,</code></pre><div id='inPattern'>In pattern: SUPERPATTERN</div><BR><div id='frequency'>Frequency: 3</div><BR><div id='size'>Non-data size: 5</div><BR><h3>Instances</h3><BR><div id='link'><a href='https://github.com/voidful/textrl/commit/77ddb40d1a9414459328b355c285deaa4856ad8b#diff-34bd53460ee7026ed47dc10c97fc4e1a427ed0dd952c7f338ba96998b0c18c69L43' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 21714955</div><div id='project'> Project Name: voidful/textrl</div><div id='commit'> Commit Name: 77ddb40d1a9414459328b355c285deaa4856ad8b</div><div id='time'> Time: 2021-06-13</div><div id='author'> Author: voidful.stack@gmail.com</div><div id='file'> File Name: textrl/environment.py</div><div id='m_class'> M Class Name: TextRLEnv</div><div id='n_method'> N Class Name: TextRLEnv</div><div id='m_method'> M Method Name: _get_obs(2)</div><div id='n_method'> N Method Name: _get_obs(2)</div><div id='m_parent_class'> M Parent Class: gym.Env</div><div id='n_parent_class'> N Parent Class: gym.Env</div><div id='m_file'> M File Name: textrl/environment.py</div><div id='n_file'> N File Name: textrl/environment.py</div><div id='m_start'> M Start Line: 44</div><div id='m_end'> M End Line: 47</div><div id='n_start'> N Start Line: 43</div><div id='n_end'> N End Line: 56</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
            has_ellipses = Ellipsis in unique_args

            _unique_type = (
                sanitized_type(args[0], primitive_only=no_nested_container, nested=True)<a id="change">
                if </a>len<a id="change">(unique_args) == 1 or (len(unique_args) == 2 and has_ellipses)
                else </a>Any
            )
            if has_ellipses:
                return Tuple[_unique_type, ...]  &#47&#47 type: ignore</code></pre><h3>After Change</h3><pre><code class='java'>
    &gt;&gt;&gt; sanitized_type(Dict[str, frozenset])
    Dict[str, Any]
    
    <a id="change">if </a><a id="change">hasattr(</a>type_, <a id="change">"__supertype__"</a><a id="change">)</a>:
        &#47&#47 is NewType
        return sanitized_type(
            type_.__supertype__,
            primitive_only=primitive_only,
            wrap_optional=wrap_optional,
            nested=nested,
        )

    &#47&#47 Warning: mutating `type_` will mutate the signature being inspected
    &#47&#47 Even calling deepcopy(`type_`) silently fails to prevent this.
    origin = get_origin(type_)
    no_nested_container = not HYDRA_SUPPORTS_NESTED_CONTAINER_TYPES

    if origin is not None:

        if isinstance(type_, _AnnotatedAlias):
            return sanitized_type(
                origin,
                primitive_only=primitive_only,
                wrap_optional=wrap_optional,
                nested=nested,
            )

        if primitive_only:  &#47&#47 pragma: no cover
            return Any

        args = get_args(type_)
        if origin is Union:
            &#47&#47 Hydra only supports Optional[&lt;type&gt;] unions
            if len(args) != 2 or NoneType not in args:
                &#47&#47 isn&quott Optional[&lt;type&gt;]
                return Any

            args = cast(Tuple[type, type], args)

            optional_type, none_type = args
            if none_type is not NoneType:
                optional_type = none_type
            optional_type: Optional[Any]
            optional_type = sanitized_type(optional_type)

            if optional_type is Any:  &#47&#47 Union[Any, T] is just Any
                return Any
            return Union[optional_type, NoneType]  &#47&#47 type: ignore

        if origin is list or origin is List:
            return List[sanitized_type(args[0], primitive_only=no_nested_container, nested=True)] if args else type_  &#47&#47 type: ignore

        if origin is dict or origin is Dict:
            return (
                Dict[
                    sanitized_type(args[0], primitive_only=True, nested=True),  &#47&#47 type: ignore
                    sanitized_type(args[1], primitive_only=no_nested_container, nested=True),  &#47&#47 type: ignore
                ]
                if args
                else type_
            )

        if (origin is tuple or origin is Tuple) and not nested:
            &#47&#47 hydra silently supports tuples of homogenous types
            &#47&#47 It has some weird behavior. It treats `Tuple[t1, t2, ...]` as `List[t1]`
            &#47&#47 It isn&quott clear that we want to perpetrate this on our end..
            &#47&#47 So we deal with inhomogeneous types as e.g. `Tuple[str, int]` -&gt; `Tuple[Any, Any]`.
            &#47&#47
            &#47&#47 Otherwise we preserve the annotation as accurately as possible
            if not args:
                return Any  &#47&#47 bare Tuple not supported by hydra
            args = cast(Tuple[type, ...], args)
            unique_args = set(args)
            has_ellipses = Ellipsis in unique_args
            has_variadic_unpack = any(get_origin(tp) is Unpack for tp in unique_args)

            if len(unique_args) == 1 or (len(unique_args) == 2 and has_ellipses):
                &#47&#47 E.g. Tuple[int, int, int] or Tuple[int, ...]
                _unique_type = sanitized_type(
                    args[0], primitive_only=no_nested_container, nested=True
                )
            elif len(unique_args) == 2 and has_variadic_unpack:
                &#47&#47 E.g. Tuple[int, *Ts]
                _a<a id="change"> = </a>Any
                for item in args:
                    if get_origin(item) is not Unpack:
                        _a<a id="change"> = </a>item
                        break
                _unique_type = sanitized_type(
                    _a, primitive_only=no_nested_container, nested=True</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/mit-ll-responsible-ai/hydra-zen/commit/616746ec193238af851b2de607f0130f4e382607#diff-ebabcec16e3caeb48b89ee03d3cc3fe9a4577145e5a820380e9becef136f956eL276' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 21714959</div><div id='project'> Project Name: mit-ll-responsible-ai/hydra-zen</div><div id='commit'> Commit Name: 616746ec193238af851b2de607f0130f4e382607</div><div id='time'> Time: 2022-06-14</div><div id='author'> Author: ry26099@mit.edu</div><div id='file'> File Name: src/hydra_zen/structured_configs/_utils.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: sanitized_type(0)</div><div id='n_method'> N Method Name: sanitized_type(0)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: src/hydra_zen/structured_configs/_utils.py</div><div id='n_file'> N File Name: src/hydra_zen/structured_configs/_utils.py</div><div id='m_start'> M Start Line: 359</div><div id='m_end'> M End Line: 366</div><div id='n_start'> N Start Line: 313</div><div id='n_end'> N End Line: 419</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
                    &#47&#47 we need to convert to a common format here first before concatenating.
                    op = workflow_node.op
                    target_kind = (
                        workflow_node.inference_supports<a id="change"> if </a>op<a id="change"> else </a>Supports.CPU_DICT_ARRAY
                    )
                    &#47&#47 note : the 2nd convert_format call needs to be stricter in what the kind is
                    &#47&#47 (exact match rather than a bitmask of values)</code></pre><h3>After Change</h3><pre><code class='java'>
                    &#47&#47 we have multiple different kinds of data here (dataframe/array on cpu/gpu)
                    &#47&#47 we need to convert to a common format here first before concatenating.
                    op = workflow_node.op
                    <a id="change">if </a>op and <a id="change">hasattr(</a>op, <a id="change">"inference_supports"</a><a id="change">)</a>:
                        target_kind<a id="change"> = </a>op.inference_supports
                    else:
                        target_kind<a id="change"> = </a>Supports.CPU_DICT_ARRAY
                    &#47&#47 note : the 2nd convert_format call needs to be stricter in what the kind is
                    &#47&#47 (exact match rather than a bitmask of values)
                    tensors, kind = convert_format(tensors, kind, target_kind)</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/nvidia/nvtabular/commit/fd429a80143d50fb3cc66d2ed01b8461568698b0#diff-24e8a8da2bb62d9cb5e1f6d788a7504f0d32fc23eb6b1b1c66bf0d3724afa946L102' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 21714975</div><div id='project'> Project Name: nvidia/nvtabular</div><div id='commit'> Commit Name: fd429a80143d50fb3cc66d2ed01b8461568698b0</div><div id='time'> Time: 2021-12-06</div><div id='author'> Author: kmhigley@gmail.com</div><div id='file'> File Name: nvtabular/inference/workflow/base.py</div><div id='m_class'> M Class Name: WorkflowRunner</div><div id='n_method'> N Class Name: WorkflowRunner</div><div id='m_method'> M Method Name: _transform_tensors(3)</div><div id='n_method'> N Method Name: _transform_tensors(3)</div><div id='m_parent_class'> M Parent Class: ABC</div><div id='n_parent_class'> N Parent Class: ABC</div><div id='m_file'> M File Name: nvtabular/inference/workflow/base.py</div><div id='n_file'> N File Name: nvtabular/inference/workflow/base.py</div><div id='m_start'> M Start Line: 115</div><div id='m_end'> M End Line: 140</div><div id='n_start'> N Start Line: 115</div><div id='n_end'> N End Line: 144</div><BR>