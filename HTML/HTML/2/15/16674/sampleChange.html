<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>

    model_train.train()
    print(&quotStart Train&quot)
    <a id="change">with tqdm</a><a id="change">(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step: 
                break
            imgs, pngs, labels = batch

            with torch.no_grad():
                imgs<a id="change">    = torch.from_numpy(</a>imgs<a id="change">)</a>.type(torch.FloatTensor)
                pngs    = torch.from_numpy(pngs).long()
                labels  = torch.from_numpy(labels).type(torch.FloatTensor)
                weights = torch.from_numpy(cls_weights)
                if cuda:
                    imgs    = imgs.cuda()
                    pngs    = pngs.cuda()
                    labels  = labels.cuda()
                    weights = weights.cuda()

            optimizer.zero_grad()
            if not fp16:
                outputs = model_train(imgs)
                if focal_loss:
                    loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
                else:
                    loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

                if dice_loss:
                    main_dice = Dice_loss(outputs, labels)
                    loss      = loss + main_dice

                with torch.no_grad():
                    &#47&#47-------------------------------&#47&#47
                    &#47&#47   计算f_score
                    &#47&#47-------------------------------&#47&#47
                    _f_score = f_score(outputs, labels)

                loss.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    outputs = model_train(imgs)
                    if focal_loss:
                        loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
                    else:
                        loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

                    if dice_loss:
                        main_dice = Dice_loss(outputs, labels)
                        loss      = loss + main_dice

                    with torch.no_grad():
                        &#47&#47-------------------------------&#47&#47
                        &#47&#47   计算f_score
                        &#47&#47-------------------------------&#47&#47
                        _f_score = f_score(outputs, labels)
                        
                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss).backward()
                scaler.step(optimizer)
                scaler.update()

            total_loss      += loss.item()
            total_f_score   += _f_score.item()
            
            pbar.set_postfix(**{&quottotal_loss&quot: total_loss / (iteration + 1), 
                                &quotf_score&quot   : total_f_score / (iteration + 1),
                                &quotlr&quot        : get_lr(optimizer)})
            pbar.update(1)

    print(&quotFinish Train&quot)

    model_train.eval()
    print(&quotStart Validation&quot)
    <a id="change">with tqdm</a><a id="change">(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            imgs, pngs, labels = batch
            with torch.no_grad():
                imgs    = torch.from_numpy(imgs).type(torch.FloatTensor)
                pngs    = torch.from_numpy(pngs).long()
                labels<a id="change">  = torch.from_numpy(labels).type(</a>torch.FloatTensor<a id="change">)</a>
                weights = torch.from_numpy(cls_weights)
                if cuda:
                    imgs    = imgs.cuda()
                    pngs    = pngs.cuda()</code></pre><h3>After Change</h3><pre><code class='java'>

    if local_rank == 0:
        print(&quotStart Train&quot)
        pbar<a id="change"> = </a><a id="change">tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)</a>
    model_train.train()
    for iteration, batch in enumerate(gen):
        if iteration &gt;= epoch_step: 
            break</code></pre>