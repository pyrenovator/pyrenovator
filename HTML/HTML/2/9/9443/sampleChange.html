<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
            &#47&#47 get per-coordinate sum of edges endpoints of each panel
            &#47&#47 should be close to sum of the equvalent number of pading values (since all of coords are shifted due to normalization\standardization)
            &#47&#47 (in case of panels, padding for edge coords should be zero, but I&quotm using a more generic solution here JIC)
            panel_coords_sum = (<a id="change">predicted_panels[el_id][:seq_len, :2]</a> - self.pad_tenzor[:2]).sum(axis=0)


        &#47&#47 batch mean of squared norms of per-panel final points:</code></pre><h3>After Change</h3><pre><code class='java'>
        self.empty_panel_template = self.empty_panel_template.to(predicted_panels.device)
        self.pad_vector = self.pad_vector.to(predicted_panels.device)
        
        <a id="change">chosen_panels</a><a id="change"> = </a><a id="change">[]</a>
        &#47&#47 choose the closest version of original panel for each predicted panel
        with torch.no_grad():
            for el_id in range(predicted_panels.shape[0]):
                num_edges = panel_len_from_padded(gt_panels[el_id], empty_template=self.empty_panel_template)

                &#47&#47 all rotations of GT
                &#47&#47 TODO Faster version? -- I think I already did smth like this somewhere
                shifted_gt_panel = gt_panels[el_id]
                min_dist = ((predicted_panels[el_id] - shifted_gt_panel) ** 2).sum()
                chosen_panel = shifted_gt_panel
                for i in range(1, num_edges):
                    shifted_gt_panel = self._rotate_edges(shifted_gt_panel, num_edges)
                    dist = ((predicted_panels[el_id] - shifted_gt_panel) ** 2).sum()
                    if dist &lt; min_dist:
                        min_dist = dist
                        chosen_panel = shifted_gt_panel
                        print(min_dist, i)

            &#47&#47 update choice
            <a id="change">chosen_panels.append(</a>chosen_panel<a id="change">)</a>

        chosen_panels<a id="change"> = </a><a id="change">torch.stack(chosen_panels</a><a id="change">)</a>.to(predicted_panels.device)

        &#47&#47 batch mean of squared norms of per-panel final points:
        <a id="change">return </a>nn.functional.mse_loss(predicted_panels, chosen_panels)
        
    def _rotate_edges(self, panel, num_edges):
        </code></pre>