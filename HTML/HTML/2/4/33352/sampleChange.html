<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
    if issubclass(typ, PRIMITIVE_JSON_TYPES):
        &#47&#47 For json literal types, we just include them directly.
        return value
    if <a id="change">issubclass(</a>typ, typing.List<a id="change">)</a>:
        &#47&#47 List[thing] annotations; create a list of things.
        args = typ.__args__  &#47&#47 type: ignore
        args = cast(List[type], args)
        if len(args) != 1:
            raise TypeError("got typing.List[] without any element type")
        if value is None:
            return None
        if not isinstance(value, typing.Sequence):
            raise TypeError(f"unable to create instance of {typ} from {value}")
        return [_instance_from_annotation(args[0], v, prevalidated) for v in value]
    if issubclass(typ, typing.Dict):
        &#47&#47 Dict[str, thing] annotations; create a dict of strings to things.
        args = typ.__args__  &#47&#47 type: ignore
        args = cast(List[type], args)
        <a id="change">if </a>len(args) != 2:
            raise TypeError("got typing.Dict[] without any element type")
        if args[0] != str:
            raise TypeError("got typing.Dict[] without a string as the first type")</code></pre><h3>After Change</h3><pre><code class='java'>
        anno = schemas.UnionBase._union_types[anno]

    &#47&#47 Any valid annotations must be plain types by now, which will allow us to use issubclass().
    <a id="change">if </a>not <a id="change">isinstance(</a>anno, type<a id="change">)</a>:
        raise TypeError(
            f"invalid compound annotation {anno}, maybe use @schemas.register_known_type?"
        )</code></pre>