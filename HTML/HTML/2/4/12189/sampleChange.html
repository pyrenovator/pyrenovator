<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>

    if check_acceptance:
        proposal.compute_acceptance.assert_called()
        <a id="change">proposal.evaluate_likelihoods.assert_called_once()</a>
        assert proposal.approx_acceptance == [0.4, 0.5]
        assert proposal.acceptance == [0.7, 0.8]
    else:
        proposal.compute_acceptance.assert_not_called()</code></pre><h3>After Change</h3><pre><code class='java'>
        numpy_array_to_live_points(np.random.randn(drawsize, n_dims), names),
        numpy_array_to_live_points(np.random.randn(drawsize, n_dims), names),
    ]
    log_l = <a id="change">np.random.rand(</a>poolsize<a id="change">)</a>

    proposal.initialised = True
    proposal.max_radius = 50
    proposal.dims = n_dims
    proposal.poolsize = poolsize
    proposal.drawsize = drawsize
    proposal.min_radius = 0.1
    proposal.fuzz = 1.0
    proposal.indices = []
    proposal.approx_acceptance = [0.4]
    proposal.acceptance = [0.7]
    proposal.keep_samples = False
    proposal.fixed_radius = False
    proposal.compute_radius_with_all = False
    proposal.check_acceptance = check_acceptance
    proposal._plot_pool = True
    proposal.populated_count = 1
    proposal.population_dtype = \
        [(&quotx_prime&quot, &quotf8&quot), (&quoty_prime&quot, &quotf8&quot), (&quotlogP&quot, &quotf8&quot), (&quotlogL&quot, &quotf8&quot)]
    proposal.draw_latent_kwargs = {&quotvar&quot: 2.0}

    proposal.forward_pass = MagicMock(return_value=(worst_z, worst_q))
    proposal.radius = MagicMock(return_value=(1.0, worst_q))
    proposal.get_alt_distribution = MagicMock(return_value=None)
    proposal.draw_latent_prior = MagicMock(side_effect=z)
    proposal.rejection_sampling = MagicMock(
        side_effect=[(a[:-1], b[:-1]) for a, b in zip(z, x)]
    )
    proposal.compute_acceptance = MagicMock(side_effect=[0.5, 0.8])
    proposal.model = MagicMock()
    proposal.model.batch_evaluate_log_likelihood = \
        MagicMock(return_value=log_l)

    proposal.plot_pool = MagicMock()
    proposal.convert_to_samples = MagicMock(
        side_effect=lambda *args, **kwargs: args[0]
    )

    FlowProposal.populate(proposal, worst_point, N=10, plot=True)

    proposal.forward_pass.assert_called_once_with(
        worst_point, rescale=True, compute_radius=True,
    )
    proposal.radius.assert_called_once_with(worst_z, worst_q)
    assert proposal.r == 1

    draw_calls = [
        call(2, r=1.0, N=5, fuzz=1.0, var=2.0),
        call(2, r=1.0, N=5, fuzz=1.0, var=2.0),
    ]
    proposal.draw_latent_prior.assert_has_calls(draw_calls)

    rejection_calls = [
        call(z[0], worst_q), call(z[1], worst_q), call(z[2], worst_q)
    ]
    proposal.rejection_sampling.assert_has_calls(rejection_calls)

    proposal.plot_pool.assert_called_once()
    proposal.convert_to_samples.assert_called_once()
    np.testing.assert_array_equal(
        proposal.convert_to_samples.call_args[0][0],
        proposal.x
    )
    assert proposal.convert_to_samples.call_args[1][&quotplot&quot] is True

    assert proposal.population_acceptance == (10 / 15)
    assert proposal.populated_count == 2
    assert proposal.populated is True
    assert proposal.x.size == 10

    if check_acceptance:
        proposal.compute_acceptance.assert_called()
        assert proposal.approx_acceptance == [0.4, 0.5]
        assert proposal.acceptance == [0.7, 0.8]
    else:
        proposal.compute_acceptance.assert_not_called()

    proposal.model.batch_evaluate_log_likelihood.assert_called_once_with(
        proposal.samples
    )
    <a id="change">np.testing.assert_array_equal(</a><a id="change">proposal.samples[&quotlogL&quot]</a>, log_l<a id="change">)</a>


def test_populate_not_initialised(proposal):
    Assert populate fails if the proposal is not initialised</code></pre>