<html><h3>Pattern ID :13106
</h3><img src='44256419.png'><BR><BR><BR><link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
            pbar.set_postfix(**{&quottotal_loss&quot: total_loss / (iteration + 1), 
                                &quotf_score&quot   : total_f_score / (iteration + 1),
                                &quotlr&quot        : get_lr(optimizer)})
            <a id="change">pbar.update(</a>1<a id="change">)</a>

    print(&quotFinish Train&quot)

    model_train.eval()</code></pre><h3>After Change</h3><pre><code class='java'>
    val_loss        = 0
    val_f_score     = 0

    <a id="change">if local_rank</a><a id="change"> == 0</a>:
        print(&quotStart Train&quot)
        pbar = tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)
    model_train.train()
    for iteration, batch in enumerate(gen):
        if iteration &gt;= epoch_step: 
            break
        imgs, pngs, labels = batch
        with torch.no_grad():
            weights = torch.from_numpy(cls_weights)
            if cuda:
                imgs    = imgs.cuda(local_rank)
                pngs    = pngs.cuda(local_rank)
                labels  = labels.cuda(local_rank)
                weights = weights.cuda(local_rank)

        optimizer.zero_grad()
        if not fp16:
            outputs = model_train(imgs)
            if focal_loss:
                loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
            else:
                loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

            if dice_loss:
                main_dice = Dice_loss(outputs, labels)
                loss      = loss + main_dice
                
            with torch.no_grad():
                &#47&#47-------------------------------&#47&#47
                &#47&#47   计算f_score
                &#47&#47-------------------------------&#47&#47
                _f_score = f_score(outputs, labels)

            loss.backward()
            optimizer.step()
        else:
            from torch.cuda.amp import autocast
            with autocast():
                outputs = model_train(imgs)
                if focal_loss:
                    loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
                else:
                    loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

                if dice_loss:
                    main_dice = Dice_loss(outputs, labels)
                    loss      = loss + main_dice

                with torch.no_grad():
                    &#47&#47-------------------------------&#47&#47
                    &#47&#47   计算f_score
                    &#47&#47-------------------------------&#47&#47
                    _f_score = f_score(outputs, labels)

            &#47&#47----------------------&#47&#47
            &#47&#47   反向传播
            &#47&#47----------------------&#47&#47
            scaler.scale(loss).backward()
            scaler.step(optimizer)
            scaler.update()
            
        total_loss      += loss.item()
        total_f_score   += _f_score.item()
        
        <a id="change">if local_rank == 0</a>:
            pbar.set_postfix(**{&quottotal_loss&quot: total_loss / (iteration + 1), 
                                &quotf_score&quot   : total_f_score / (iteration + 1),
                                &quotlr&quot        : get_lr(optimizer)})
            <a id="change">pbar.update(</a>1<a id="change">)</a>

    <a id="change">if local_rank</a><a id="change"> == 0</a>:
        pbar.close()
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)

    model_train.eval()
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        imgs, pngs, labels = batch
        with torch.no_grad():
            weights = torch.from_numpy(cls_weights)
            if cuda:
                imgs    = imgs.cuda(local_rank)
                pngs    = pngs.cuda(local_rank)
                labels  = labels.cuda(local_rank)
                weights = weights.cuda(local_rank)

            outputs     = model_train(imgs)
            if focal_loss:
                loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
            else:
                loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

            if dice_loss:
                main_dice = Dice_loss(outputs, labels)
                loss  = loss + main_dice
            &#47&#47-------------------------------&#47&#47
            &#47&#47   计算f_score
            &#47&#47-------------------------------&#47&#47
            _f_score    = f_score(outputs, labels)

            val_loss    += loss.item()
            val_f_score += _f_score.item()
            
        <a id="change">if local_rank</a><a id="change"> == 0</a>:
            pbar.set_postfix(**{&quotval_loss&quot  : val_loss / (iteration + 1),
                                &quotf_score&quot   : val_f_score / (iteration + 1),
                                &quotlr&quot        : get_lr(optimizer)})
            pbar.update(1)
            
    <a id="change">if local_rank</a><a id="change"> == 0</a>:
        pbar.close()
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, total_loss / epoch_step, val_loss / epoch_step_val)</code></pre><div id='inPattern'>In pattern: SUPERPATTERN</div><BR><div id='frequency'>Frequency: 8</div><BR><div id='size'>Non-data size: 12</div><BR><h3>Instances</h3><BR><div id='link'><a href='https://github.com/bubbliiiing/hrnet-pytorch/commit/db25ef252fa24b7ff1ebd48ef7c8b918ff707e18#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L11' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 44256419</div><div id='project'> Project Name: bubbliiiing/hrnet-pytorch</div><div id='commit'> Commit Name: db25ef252fa24b7ff1ebd48ef7c8b918ff707e18</div><div id='time'> Time: 2022-04-15</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(20)</div><div id='n_method'> N Method Name: fit_one_epoch(19)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 11</div><div id='m_end'> M End Line: 138</div><div id='n_start'> N Start Line: 12</div><div id='n_end'> N End Line: 139</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
            pbar.set_postfix(**{&quottotal_loss&quot: val_loss / (iteration + 1),
                                &quotf_score&quot   : val_f_score / (iteration + 1),
                                &quotlr&quot        : get_lr(optimizer)})
            <a id="change">pbar.update(</a>1<a id="change">)</a>
            
    print(&quotFinish Validation&quot)
    loss_history.append_loss(epoch + 1, total_loss / epoch_step, val_loss / epoch_step_val)
    print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre><h3>After Change</h3><pre><code class='java'>
    val_loss        = 0
    val_f_score     = 0

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotStart Train&quot)
        pbar = tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)
    model_train.train()
    for iteration, batch in enumerate(gen):
        if iteration &gt;= epoch_step: 
            break
        imgs, pngs, labels = batch
        with torch.no_grad():
            weights = torch.from_numpy(cls_weights)
            if cuda:
                imgs    = imgs.cuda(local_rank)
                pngs    = pngs.cuda(local_rank)
                labels  = labels.cuda(local_rank)
                weights = weights.cuda(local_rank)

        optimizer.zero_grad()
        if not fp16:
            outputs = model_train(imgs)
            if focal_loss:
                loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
            else:
                loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

            if dice_loss:
                main_dice = Dice_loss(outputs, labels)
                loss      = loss + main_dice
                
            with torch.no_grad():
                &#47&#47-------------------------------&#47&#47
                &#47&#47   计算f_score
                &#47&#47-------------------------------&#47&#47
                _f_score = f_score(outputs, labels)

            loss.backward()
            optimizer.step()
        else:
            from torch.cuda.amp import autocast
            with autocast():
                outputs = model_train(imgs)
                if focal_loss:
                    loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
                else:
                    loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

                if dice_loss:
                    main_dice = Dice_loss(outputs, labels)
                    loss      = loss + main_dice

                with torch.no_grad():
                    &#47&#47-------------------------------&#47&#47
                    &#47&#47   计算f_score
                    &#47&#47-------------------------------&#47&#47
                    _f_score = f_score(outputs, labels)

            &#47&#47----------------------&#47&#47
            &#47&#47   反向传播
            &#47&#47----------------------&#47&#47
            scaler.scale(loss).backward()
            scaler.step(optimizer)
            scaler.update()
            
        total_loss      += loss.item()
        total_f_score   += _f_score.item()
        
        <a id="change">if </a><a id="change">local_rank == 0</a>:
            pbar.set_postfix(**{&quottotal_loss&quot: total_loss / (iteration + 1), 
                                &quotf_score&quot   : total_f_score / (iteration + 1),
                                &quotlr&quot        : get_lr(optimizer)})
            pbar.update(1)

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        pbar.close()
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)

    model_train.eval()
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        imgs, pngs, labels = batch
        with torch.no_grad():
            weights = torch.from_numpy(cls_weights)
            if cuda:
                imgs    = imgs.cuda(local_rank)
                pngs    = pngs.cuda(local_rank)
                labels  = labels.cuda(local_rank)
                weights = weights.cuda(local_rank)

            outputs     = model_train(imgs)
            if focal_loss:
                loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
            else:
                loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

            if dice_loss:
                main_dice = Dice_loss(outputs, labels)
                loss  = loss + main_dice
            &#47&#47-------------------------------&#47&#47
            &#47&#47   计算f_score
            &#47&#47-------------------------------&#47&#47
            _f_score    = f_score(outputs, labels)

            val_loss    += loss.item()
            val_f_score += _f_score.item()
            
        <a id="change">if local_rank == 0</a>:
            pbar.set_postfix(**{&quotval_loss&quot  : val_loss / (iteration + 1),
                                &quotf_score&quot   : val_f_score / (iteration + 1),
                                &quotlr&quot        : get_lr(optimizer)})
            <a id="change">pbar.update(</a>1<a id="change">)</a>
            
    <a id="change">if </a><a id="change">local_rank == 0</a>:
        pbar.close()
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, total_loss / epoch_step, val_loss / epoch_step_val)</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/hrnet-pytorch/commit/db25ef252fa24b7ff1ebd48ef7c8b918ff707e18#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L11' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 44256418</div><div id='project'> Project Name: bubbliiiing/hrnet-pytorch</div><div id='commit'> Commit Name: db25ef252fa24b7ff1ebd48ef7c8b918ff707e18</div><div id='time'> Time: 2022-04-15</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(20)</div><div id='n_method'> N Method Name: fit_one_epoch(19)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 11</div><div id='m_end'> M End Line: 138</div><div id='n_start'> N Start Line: 12</div><div id='n_end'> N End Line: 139</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>

                val_loss += val_total.item()
                pbar.set_postfix(**{&quotval_loss&quot  : val_loss / (iteration + 1)})
                <a id="change">pbar.update(</a>1<a id="change">)</a>

    print(&quotFinish Validation&quot)
    loss_history.append_loss(epoch + 1, total_loss / epoch_step, val_loss / epoch_step_val)</code></pre><h3>After Change</h3><pre><code class='java'>
    roi_cls_loss = 0
    
    val_loss = 0
    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotStart Train&quot)
        pbar = tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)
    for iteration, batch in enumerate(gen):
        if iteration &gt;= epoch_step:
            break
        images, boxes, labels = batch[0], batch[1], batch[2]
        with torch.no_grad():
            if cuda:
                images = images.cuda()

        rpn_loc, rpn_cls, roi_loc, roi_cls, total = train_util.train_step(images, boxes, labels, 1, fp16, scaler)
        total_loss      += total.item()
        rpn_loc_loss    += rpn_loc.item()
        rpn_cls_loss    += rpn_cls.item()
        roi_loc_loss    += roi_loc.item()
        roi_cls_loss    += roi_cls.item()
        
        <a id="change">if </a><a id="change">local_rank == 0</a>:
            pbar.set_postfix(**{&quottotal_loss&quot    : total_loss / (iteration + 1), 
                                &quotrpn_loc&quot       : rpn_loc_loss / (iteration + 1),  
                                &quotrpn_cls&quot       : rpn_cls_loss / (iteration + 1), 
                                &quotroi_loc&quot       : roi_loc_loss / (iteration + 1), 
                                &quotroi_cls&quot       : roi_cls_loss / (iteration + 1), 
                                &quotlr&quot            : get_lr(optimizer)})
            pbar.update(1)

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        pbar.close()
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        images, boxes, labels = batch[0], batch[1], batch[2]
        with torch.no_grad():
            if cuda:
                images = images.cuda()

            train_util.optimizer.zero_grad()
            _, _, _, _, val_total = train_util.forward(images, boxes, labels, 1)
            val_loss += val_total.item()
            
            <a id="change">if local_rank == 0</a>:
                pbar.set_postfix(**{&quotval_loss&quot  : val_loss / (iteration + 1)})
                <a id="change">pbar.update(</a>1<a id="change">)</a>

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        pbar.close()
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, total_loss / epoch_step, val_loss / epoch_step_val)</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/faster-rcnn-pytorch/commit/05e6e50b241e1ae4707e28c3b3fc388fd7141eb4#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 44256416</div><div id='project'> Project Name: bubbliiiing/faster-rcnn-pytorch</div><div id='commit'> Commit Name: 05e6e50b241e1ae4707e28c3b3fc388fd7141eb4</div><div id='time'> Time: 2022-04-20</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(16)</div><div id='n_method'> N Method Name: fit_one_epoch(13)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 17</div><div id='m_end'> M End Line: 68</div><div id='n_start'> N Start Line: 9</div><div id='n_end'> N End Line: 72</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
            
            pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                &quotlr&quot    : get_lr(optimizer)})
            <a id="change">pbar.update(</a>1<a id="change">)</a>

    print(&quotFinish Train&quot)
</code></pre><h3>After Change</h3><pre><code class='java'>
    loss        = 0
    val_loss    = 0

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotStart Train&quot)
    model_train.train()
    with tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   前向传播
                    &#47&#47----------------------&#47&#47
                    outputs         = model_train(images)

                    loss_value_all  = 0
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    for l in range(len(outputs)):
                        loss_item = yolo_loss(l, outputs[l], targets)
                        loss_value_all  += loss_item
                    loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            <a id="change">if local_rank == 0</a>:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                <a id="change">pbar.update(</a>1<a id="change">)</a>

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    with tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
                &#47&#47----------------------&#47&#47
                &#47&#47   清零梯度
                &#47&#47----------------------&#47&#47
                optimizer.zero_grad()
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value  = loss_value_all

            val_loss += loss_value.item()
            <a id="change">if </a><a id="change">local_rank == 0</a>:
                pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
                pbar.update(1)

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/yolov5-pytorch/commit/2975e836b17879df337a36a0d1d6f592fc0b1bc2#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L8' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 44256423</div><div id='project'> Project Name: bubbliiiing/yolov5-pytorch</div><div id='commit'> Commit Name: 2975e836b17879df337a36a0d1d6f592fc0b1bc2</div><div id='time'> Time: 2022-04-12</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(16)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 13</div><div id='m_end'> M End Line: 125</div><div id='n_start'> N Start Line: 8</div><div id='n_end'> N End Line: 129</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>

                pbar.set_postfix(**{&quotval_loss&quot    : val_loss / (iteration + 1), 
                                    &quotlr&quot            : get_lr(optimizer)})
                <a id="change">pbar.update(</a>1<a id="change">)</a>

    print(&quotFinish Validation&quot)
    loss_history.append_loss(epoch + 1, total_loss / epoch_step, val_loss / epoch_step_val)</code></pre><h3>After Change</h3><pre><code class='java'>
    total_loss  = 0
    val_loss    = 0 

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotStart Train&quot)
    model_train.train()
    with tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break
            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = torch.from_numpy(targets).type(torch.FloatTensor).cuda()
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = torch.from_numpy(targets).type(torch.FloatTensor) 
            &#47&#47----------------------&#47&#47
            &#47&#47   前向传播
            &#47&#47----------------------&#47&#47
            out = model_train(images)
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   清零梯度
                &#47&#47----------------------&#47&#47
                optimizer.zero_grad()
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                loss = ssd_loss.forward(targets, out)
                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   清零梯度
                    &#47&#47----------------------&#47&#47
                    optimizer.zero_grad()
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    loss = ssd_loss.forward(targets, out)

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss).backward()
                scaler.step(optimizer)
                scaler.update()

            total_loss += loss.item()
            
            <a id="change">if </a><a id="change">local_rank == 0</a>:
                pbar.set_postfix(**{&quottotal_loss&quot    : total_loss / (iteration + 1), 
                                    &quotlr&quot            : get_lr(optimizer)})
                pbar.update(1)
                
    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    with tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = torch.from_numpy(targets).type(torch.FloatTensor).cuda()
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = torch.from_numpy(targets).type(torch.FloatTensor) 

                out = model_train(images)
                optimizer.zero_grad()
                loss = ssd_loss.forward(targets, out)
                val_loss += loss.item()

                <a id="change">if local_rank == 0</a>:
                    pbar.set_postfix(**{&quotval_loss&quot      : val_loss / (iteration + 1), 
                                        &quotlr&quot            : get_lr(optimizer)})
                    <a id="change">pbar.update(</a>1<a id="change">)</a>

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, total_loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch+1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/ssd-pytorch/commit/b3d1c723afaeebfab1b5aa5ba5e1a06ede74e6e0#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 44256427</div><div id='project'> Project Name: bubbliiiing/ssd-pytorch</div><div id='commit'> Commit Name: b3d1c723afaeebfab1b5aa5ba5e1a06ede74e6e0</div><div id='time'> Time: 2022-04-13</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(16)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 14</div><div id='m_end'> M End Line: 101</div><div id='n_start'> N Start Line: 9</div><div id='n_end'> N End Line: 106</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>

            val_loss += loss_value.item()
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            <a id="change">pbar.update(</a>1<a id="change">)</a>

    print(&quotFinish Validation&quot)
    </code></pre><h3>After Change</h3><pre><code class='java'>
    loss        = 0
    val_loss    = 0

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotStart Train&quot)
    model_train.train()
    with tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                loss_value = yolo_loss(outputs, targets)

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    outputs = model_train(images)
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    loss_value = yolo_loss(outputs, targets)

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            <a id="change">if </a><a id="change">local_rank == 0</a>:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    with tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
                &#47&#47----------------------&#47&#47
                &#47&#47   清零梯度
                &#47&#47----------------------&#47&#47
                optimizer.zero_grad()
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                loss_value = yolo_loss(outputs, targets)

            val_loss += loss_value.item()
            <a id="change">if local_rank == 0</a>:
                pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
                <a id="change">pbar.update(</a>1<a id="change">)</a>

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/yolox-pytorch/commit/16f77f27c4889814aadf653c84748f80eb222862#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 44256409</div><div id='project'> Project Name: bubbliiiing/yolox-pytorch</div><div id='commit'> Commit Name: 16f77f27c4889814aadf653c84748f80eb222862</div><div id='time'> Time: 2022-04-12</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(16)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 14</div><div id='m_end'> M End Line: 110</div><div id='n_start'> N Start Line: 9</div><div id='n_end'> N End Line: 114</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>

            val_loss += loss_value.item()
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            <a id="change">pbar.update(</a>1<a id="change">)</a>

    print(&quotFinish Validation&quot)
    </code></pre><h3>After Change</h3><pre><code class='java'>
    loss        = 0
    val_loss    = 0

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotStart Train&quot)
    model_train.train()
    with tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   前向传播
                    &#47&#47----------------------&#47&#47
                    outputs         = model_train(images)

                    loss_value_all  = 0
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    for l in range(len(outputs)):
                        loss_item = yolo_loss(l, outputs[l], targets)
                        loss_value_all  += loss_item
                    loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            <a id="change">if </a><a id="change">local_rank == 0</a>:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    with tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
                &#47&#47----------------------&#47&#47
                &#47&#47   清零梯度
                &#47&#47----------------------&#47&#47
                optimizer.zero_grad()
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value  = loss_value_all

            val_loss += loss_value.item()
            <a id="change">if local_rank == 0</a>:
                pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
                <a id="change">pbar.update(</a>1<a id="change">)</a>

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/yolov4-pytorch/commit/eda96cab3f3e7a355b6df9f3f2ab56e20aacc2fd#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 44256431</div><div id='project'> Project Name: bubbliiiing/yolov4-pytorch</div><div id='commit'> Commit Name: eda96cab3f3e7a355b6df9f3f2ab56e20aacc2fd</div><div id='time'> Time: 2022-04-13</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(16)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 14</div><div id='m_end'> M End Line: 126</div><div id='n_start'> N Start Line: 9</div><div id='n_end'> N End Line: 130</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>

            val_loss += loss_value.item()
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            <a id="change">pbar.update(</a>1<a id="change">)</a>

    print(&quotFinish Validation&quot)
    </code></pre><h3>After Change</h3><pre><code class='java'>
    loss        = 0
    val_loss    = 0

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotStart Train&quot)
    model_train.train()
    with tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   前向传播
                    &#47&#47----------------------&#47&#47
                    outputs         = model_train(images)

                    loss_value_all  = 0
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    for l in range(len(outputs)):
                        loss_item = yolo_loss(l, outputs[l], targets)
                        loss_value_all  += loss_item
                    loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            <a id="change">if </a><a id="change">local_rank == 0</a>:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    with tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
                &#47&#47----------------------&#47&#47
                &#47&#47   清零梯度
                &#47&#47----------------------&#47&#47
                optimizer.zero_grad()
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value  = loss_value_all

            val_loss += loss_value.item()
            <a id="change">if local_rank == 0</a>:
                pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
                <a id="change">pbar.update(</a>1<a id="change">)</a>

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))
        print(&quotTotal Loss: %.3f || Val Loss: %.3f &quot % (loss / epoch_step, val_loss / epoch_step_val))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/efficientnet-yolo3-pytorch/commit/2c8c4182c9012b49a92c54d0406b63a231346c65#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 44256429</div><div id='project'> Project Name: bubbliiiing/efficientnet-yolo3-pytorch</div><div id='commit'> Commit Name: 2c8c4182c9012b49a92c54d0406b63a231346c65</div><div id='time'> Time: 2022-04-13</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(16)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 14</div><div id='m_end'> M End Line: 126</div><div id='n_start'> N Start Line: 9</div><div id='n_end'> N End Line: 129</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>

            val_loss += loss_value.item()
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            <a id="change">pbar.update(</a>1<a id="change">)</a>

    print(&quotFinish Validation&quot)
    </code></pre><h3>After Change</h3><pre><code class='java'>
    loss        = 0
    val_loss    = 0

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotStart Train&quot)
    model_train.train()
    with tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   前向传播
                    &#47&#47----------------------&#47&#47
                    outputs         = model_train(images)

                    loss_value_all  = 0
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    for l in range(len(outputs)):
                        loss_item = yolo_loss(l, outputs[l], targets)
                        loss_value_all  += loss_item
                    loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            <a id="change">if </a><a id="change">local_rank == 0</a>:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    with tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
                &#47&#47----------------------&#47&#47
                &#47&#47   清零梯度
                &#47&#47----------------------&#47&#47
                optimizer.zero_grad()
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value  = loss_value_all

            val_loss += loss_value.item()
            <a id="change">if local_rank == 0</a>:
                pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
                <a id="change">pbar.update(</a>1<a id="change">)</a>

    <a id="change">if </a><a id="change">local_rank == 0</a>:
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))
        print(&quotTotal Loss: %.3f || Val Loss: %.3f &quot % (loss / epoch_step, val_loss / epoch_step_val))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/yolo3-pytorch/commit/75e27a4554fd6256d5f8e397e12b5dcc397cb870#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 44256428</div><div id='project'> Project Name: bubbliiiing/yolo3-pytorch</div><div id='commit'> Commit Name: 75e27a4554fd6256d5f8e397e12b5dcc397cb870</div><div id='time'> Time: 2022-04-13</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(16)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 14</div><div id='m_end'> M End Line: 126</div><div id='n_start'> N Start Line: 9</div><div id='n_end'> N End Line: 129</div><BR>