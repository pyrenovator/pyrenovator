<html><h3>Pattern ID :2673
</h3><img src='10895654.png'><BR><BR><BR><link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
    if local_rank == 0:
        print(&quotStart Train&quot)
    model_train.train()
    <a id="change">with </a><a id="change">tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   前向传播
                    &#47&#47----------------------&#47&#47
                    outputs         = model_train(images)

                    loss_value_all  = 0
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    for l in range(len(outputs)):
                        loss_item = yolo_loss(l, outputs[l], targets)
                        loss_value_all  += loss_item
                    loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            if local_rank == 0:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    if local_rank == 0:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    <a id="change">with tqdm</a><a id="change">(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]</code></pre><h3>After Change</h3><pre><code class='java'>
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)

    model_train.eval()
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        images, targets = batch[0], batch[1]
        with torch.no_grad():
            if cuda:
                images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
            else:
                images  = torch.from_numpy(images).type(torch.FloatTensor)
                targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            &#47&#47----------------------&#47&#47
            &#47&#47   前向传播
            &#47&#47----------------------&#47&#47
            outputs         = model_train(images)

            loss_value_all  = 0
            &#47&#47----------------------&#47&#47
            &#47&#47   计算损失
            &#47&#47----------------------&#47&#47
            for l in range(len(outputs)):
                loss_item = yolo_loss(l, outputs[l], targets)
                loss_value_all  += loss_item
            loss_value  = loss_value_all

        val_loss += loss_value.item()
        if local_rank == 0:
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            pbar.update(1)
 
    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre><div id='inPattern'>In pattern: SUPERPATTERN</div><BR><div id='frequency'>Frequency: 8</div><BR><div id='size'>Non-data size: 6</div><BR><h3>Instances</h3><BR><div id='link'><a href='https://github.com/bubbliiiing/yolo3-pytorch/commit/0cf1fb49d2931a04997a1972d847427bce94d736#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L15' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 10895654</div><div id='project'> Project Name: bubbliiiing/yolo3-pytorch</div><div id='commit'> Commit Name: 0cf1fb49d2931a04997a1972d847427bce94d736</div><div id='time'> Time: 2022-04-14</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(17)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 16</div><div id='m_end'> M End Line: 124</div><div id='n_start'> N Start Line: 15</div><div id='n_end'> N End Line: 127</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
    
    val_loss = 0
    print(&quotStart Train&quot)
    <a id="change">with </a><a id="change">tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break
            images, boxes, labels = batch[0], batch[1], batch[2]
            with torch.no_grad():
                images = torch.from_numpy(images).type(torch.FloatTensor)
                if cuda:
                    images = images.cuda()

            rpn_loc, rpn_cls, roi_loc, roi_cls, total = train_util.train_step(images, boxes, labels, 1)
            total_loss      += total.item()
            rpn_loc_loss    += rpn_loc.item()
            rpn_cls_loss    += rpn_cls.item()
            roi_loc_loss    += roi_loc.item()
            roi_cls_loss    += roi_cls.item()
            
            pbar.set_postfix(**{&quottotal_loss&quot    : total_loss / (iteration + 1), 
                                &quotrpn_loc&quot       : rpn_loc_loss / (iteration + 1),  
                                &quotrpn_cls&quot       : rpn_cls_loss / (iteration + 1), 
                                &quotroi_loc&quot       : roi_loc_loss / (iteration + 1), 
                                &quotroi_cls&quot       : roi_cls_loss / (iteration + 1), 
                                &quotlr&quot            : get_lr(optimizer)})
            pbar.update(1)

    print(&quotFinish Train&quot)

    print(&quotStart Validation&quot)
    <a id="change">with </a><a id="change">tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images,boxes,labels = batch[0], batch[1], batch[2]</code></pre><h3>After Change</h3><pre><code class='java'>
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        images, boxes, labels = batch[0], batch[1], batch[2]
        with torch.no_grad():
            if cuda:
                images = images.cuda()

            train_util.optimizer.zero_grad()
            _, _, _, _, val_total = train_util.forward(images, boxes, labels, 1)
            val_loss += val_total.item()
            
            if local_rank == 0:
                pbar.set_postfix(**{&quotval_loss&quot  : val_loss / (iteration + 1)})
                pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, total_loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/faster-rcnn-pytorch/commit/05e6e50b241e1ae4707e28c3b3fc388fd7141eb4#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 10895655</div><div id='project'> Project Name: bubbliiiing/faster-rcnn-pytorch</div><div id='commit'> Commit Name: 05e6e50b241e1ae4707e28c3b3fc388fd7141eb4</div><div id='time'> Time: 2022-04-20</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(16)</div><div id='n_method'> N Method Name: fit_one_epoch(13)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 17</div><div id='m_end'> M End Line: 68</div><div id='n_start'> N Start Line: 9</div><div id='n_end'> N End Line: 72</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
    if local_rank == 0:
        print(&quotStart Train&quot)
    model_train.train()
    <a id="change">with </a><a id="change">tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   前向传播
                    &#47&#47----------------------&#47&#47
                    outputs         = model_train(images)

                    loss_value_all  = 0
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    for l in range(len(outputs)):
                        loss_item = yolo_loss(l, outputs[l], targets)
                        loss_value_all  += loss_item
                    loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            if local_rank == 0:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    if local_rank == 0:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    <a id="change">with </a><a id="change">tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]</code></pre><h3>After Change</h3><pre><code class='java'>
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)

    model_train.eval()
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        images, targets = batch[0], batch[1]
        with torch.no_grad():
            if cuda:
                images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
            else:
                images  = torch.from_numpy(images).type(torch.FloatTensor)
                targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            &#47&#47----------------------&#47&#47
            &#47&#47   前向传播
            &#47&#47----------------------&#47&#47
            outputs         = model_train(images)

            loss_value_all  = 0
            &#47&#47----------------------&#47&#47
            &#47&#47   计算损失
            &#47&#47----------------------&#47&#47
            for l in range(len(outputs)):
                loss_item = yolo_loss(l, outputs[l], targets)
                loss_value_all  += loss_item
            loss_value  = loss_value_all

        val_loss += loss_value.item()
        if local_rank == 0:
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            pbar.update(1)
            
    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/yolov5-pytorch/commit/bfefd7fa75af109433d85ac9cb2dce73e6912cd7#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L8' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 10895652</div><div id='project'> Project Name: bubbliiiing/yolov5-pytorch</div><div id='commit'> Commit Name: bfefd7fa75af109433d85ac9cb2dce73e6912cd7</div><div id='time'> Time: 2022-04-14</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(17)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 15</div><div id='m_end'> M End Line: 123</div><div id='n_start'> N Start Line: 14</div><div id='n_end'> N End Line: 125</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>

    model_train.train()
    print(&quotStart Train&quot)
    <a id="change">with </a><a id="change">tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step: 
                break
            imgs, pngs, labels = batch

            with torch.no_grad():
                imgs    = torch.from_numpy(imgs).type(torch.FloatTensor)
                pngs    = torch.from_numpy(pngs).long()
                labels  = torch.from_numpy(labels).type(torch.FloatTensor)
                weights = torch.from_numpy(cls_weights)
                if cuda:
                    imgs    = imgs.cuda()
                    pngs    = pngs.cuda()
                    labels  = labels.cuda()
                    weights = weights.cuda()

            optimizer.zero_grad()
            if not fp16:
                outputs = model_train(imgs)
                if focal_loss:
                    loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
                else:
                    loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

                if dice_loss:
                    main_dice = Dice_loss(outputs, labels)
                    loss      = loss + main_dice

                with torch.no_grad():
                    &#47&#47-------------------------------&#47&#47
                    &#47&#47   计算f_score
                    &#47&#47-------------------------------&#47&#47
                    _f_score = f_score(outputs, labels)

                loss.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    outputs = model_train(imgs)
                    if focal_loss:
                        loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
                    else:
                        loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

                    if dice_loss:
                        main_dice = Dice_loss(outputs, labels)
                        loss      = loss + main_dice

                    with torch.no_grad():
                        &#47&#47-------------------------------&#47&#47
                        &#47&#47   计算f_score
                        &#47&#47-------------------------------&#47&#47
                        _f_score = f_score(outputs, labels)
                        
                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss).backward()
                scaler.step(optimizer)
                scaler.update()

            total_loss      += loss.item()
            total_f_score   += _f_score.item()
            
            pbar.set_postfix(**{&quottotal_loss&quot: total_loss / (iteration + 1), 
                                &quotf_score&quot   : total_f_score / (iteration + 1),
                                &quotlr&quot        : get_lr(optimizer)})
            pbar.update(1)

    print(&quotFinish Train&quot)

    model_train.eval()
    print(&quotStart Validation&quot)
    <a id="change">with tqdm</a><a id="change">(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            imgs, pngs, labels = batch</code></pre><h3>After Change</h3><pre><code class='java'>
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)

    model_train.eval()
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        imgs, pngs, labels = batch
        with torch.no_grad():
            weights = torch.from_numpy(cls_weights)
            if cuda:
                imgs    = imgs.cuda(local_rank)
                pngs    = pngs.cuda(local_rank)
                labels  = labels.cuda(local_rank)
                weights = weights.cuda(local_rank)

            outputs     = model_train(imgs)
            if focal_loss:
                loss = Focal_Loss(outputs, pngs, weights, num_classes = num_classes)
            else:
                loss = CE_Loss(outputs, pngs, weights, num_classes = num_classes)

            if dice_loss:
                main_dice = Dice_loss(outputs, labels)
                loss  = loss + main_dice
            &#47&#47-------------------------------&#47&#47
            &#47&#47   计算f_score
            &#47&#47-------------------------------&#47&#47
            _f_score    = f_score(outputs, labels)

            val_loss    += loss.item()
            val_f_score += _f_score.item()
            
        if local_rank == 0:
            pbar.set_postfix(**{&quotval_loss&quot  : val_loss / (iteration + 1),
                                &quotf_score&quot   : val_f_score / (iteration + 1),
                                &quotlr&quot        : get_lr(optimizer)})
            pbar.update(1)
            
    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, total_loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))
        print(&quotTotal Loss: %.3f || Val Loss: %.3f &quot % (total_loss / epoch_step, val_loss / epoch_step_val))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/hrnet-pytorch/commit/db25ef252fa24b7ff1ebd48ef7c8b918ff707e18#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L11' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 10895653</div><div id='project'> Project Name: bubbliiiing/hrnet-pytorch</div><div id='commit'> Commit Name: db25ef252fa24b7ff1ebd48ef7c8b918ff707e18</div><div id='time'> Time: 2022-04-15</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(20)</div><div id='n_method'> N Method Name: fit_one_epoch(19)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 11</div><div id='m_end'> M End Line: 138</div><div id='n_start'> N Start Line: 12</div><div id='n_end'> N End Line: 139</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
    if local_rank == 0:
        print(&quotStart Train&quot)
    model_train.train()
    <a id="change">with </a><a id="change">tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   前向传播
                    &#47&#47----------------------&#47&#47
                    outputs         = model_train(images)

                    loss_value_all  = 0
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    for l in range(len(outputs)):
                        loss_item = yolo_loss(l, outputs[l], targets)
                        loss_value_all  += loss_item
                    loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            if local_rank == 0:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    if local_rank == 0:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    <a id="change">with tqdm</a><a id="change">(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]</code></pre><h3>After Change</h3><pre><code class='java'>
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)

    model_train.eval()
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        images, targets = batch[0], batch[1]
        with torch.no_grad():
            if cuda:
                images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
            else:
                images  = torch.from_numpy(images).type(torch.FloatTensor)
                targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            &#47&#47----------------------&#47&#47
            &#47&#47   前向传播
            &#47&#47----------------------&#47&#47
            outputs         = model_train(images)

            loss_value_all  = 0
            &#47&#47----------------------&#47&#47
            &#47&#47   计算损失
            &#47&#47----------------------&#47&#47
            for l in range(len(outputs)):
                loss_item = yolo_loss(l, outputs[l], targets)
                loss_value_all  += loss_item
            loss_value  = loss_value_all

        val_loss += loss_value.item()
        if local_rank == 0:
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            pbar.update(1)
 
    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/efficientnet-yolo3-pytorch/commit/8619fe7d9297c81967fbd92016f598a1d003fa31#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 10895650</div><div id='project'> Project Name: bubbliiiing/efficientnet-yolo3-pytorch</div><div id='commit'> Commit Name: 8619fe7d9297c81967fbd92016f598a1d003fa31</div><div id='time'> Time: 2022-04-14</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(17)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 16</div><div id='m_end'> M End Line: 124</div><div id='n_start'> N Start Line: 15</div><div id='n_end'> N End Line: 127</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
    if local_rank == 0:
        print(&quotStart Train&quot)
    model_train.train()
    <a id="change">with </a><a id="change">tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                loss_value = yolo_loss(outputs, targets)

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    outputs = model_train(images)
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    loss_value = yolo_loss(outputs, targets)

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            if local_rank == 0:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    if local_rank == 0:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    <a id="change">with tqdm</a><a id="change">(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]</code></pre><h3>After Change</h3><pre><code class='java'>
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)

    model_train.eval()
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        images, targets = batch[0], batch[1]
        with torch.no_grad():
            if cuda:
                images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
            else:
                images  = torch.from_numpy(images).type(torch.FloatTensor)
                targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            &#47&#47----------------------&#47&#47
            &#47&#47   前向传播
            &#47&#47----------------------&#47&#47
            outputs         = model_train(images)

            &#47&#47----------------------&#47&#47
            &#47&#47   计算损失
            &#47&#47----------------------&#47&#47
            loss_value = yolo_loss(outputs, targets)

        val_loss += loss_value.item()
        if local_rank == 0:
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/yolox-pytorch/commit/4eda5677dea65035bbf80bd9be4cac78fb460f9e#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 10895649</div><div id='project'> Project Name: bubbliiiing/yolox-pytorch</div><div id='commit'> Commit Name: 4eda5677dea65035bbf80bd9be4cac78fb460f9e</div><div id='time'> Time: 2022-04-14</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(17)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 16</div><div id='m_end'> M End Line: 108</div><div id='n_start'> N Start Line: 15</div><div id='n_end'> N End Line: 110</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
    if local_rank == 0:
        print(&quotStart Train&quot)
    model_train.train()
    <a id="change">with </a><a id="change">tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   前向传播
                    &#47&#47----------------------&#47&#47
                    outputs         = model_train(images)

                    loss_value_all  = 0
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    for l in range(len(outputs)):
                        loss_item = yolo_loss(l, outputs[l], targets)
                        loss_value_all  += loss_item
                    loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            if local_rank == 0:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    if local_rank == 0:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    <a id="change">with </a><a id="change">tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]</code></pre><h3>After Change</h3><pre><code class='java'>
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)

    model_train.eval()
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        images, targets = batch[0], batch[1]
        with torch.no_grad():
            if cuda:
                images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
            else:
                images  = torch.from_numpy(images).type(torch.FloatTensor)
                targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            &#47&#47----------------------&#47&#47
            &#47&#47   前向传播
            &#47&#47----------------------&#47&#47
            outputs         = model_train(images)

            loss_value_all  = 0
            &#47&#47----------------------&#47&#47
            &#47&#47   计算损失
            &#47&#47----------------------&#47&#47
            for l in range(len(outputs)):
                loss_item = yolo_loss(l, outputs[l], targets)
                loss_value_all  += loss_item
            loss_value  = loss_value_all

        val_loss += loss_value.item()
        if local_rank == 0:
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/yolov4-pytorch/commit/f79864a49bfc53786a99955fd20e50b2c1be735b#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 10895663</div><div id='project'> Project Name: bubbliiiing/yolov4-pytorch</div><div id='commit'> Commit Name: f79864a49bfc53786a99955fd20e50b2c1be735b</div><div id='time'> Time: 2022-04-14</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(17)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 16</div><div id='m_end'> M End Line: 124</div><div id='n_start'> N Start Line: 15</div><div id='n_end'> N End Line: 126</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
    if local_rank == 0:
        print(&quotStart Train&quot)
    model_train.train()
    <a id="change">with </a><a id="change">tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   前向传播
                    &#47&#47----------------------&#47&#47
                    outputs         = model_train(images)

                    loss_value_all  = 0
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    for l in range(len(outputs)):
                        loss_item = yolo_loss(l, outputs[l], targets)
                        loss_value_all  += loss_item
                    loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            if local_rank == 0:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    if local_rank == 0:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    <a id="change">with tqdm</a><a id="change">(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]</code></pre><h3>After Change</h3><pre><code class='java'>
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)

    model_train.eval()
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        images, targets = batch[0], batch[1]
        with torch.no_grad():
            if cuda:
                images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
            else:
                images  = torch.from_numpy(images).type(torch.FloatTensor)
                targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            &#47&#47----------------------&#47&#47
            &#47&#47   前向传播
            &#47&#47----------------------&#47&#47
            outputs         = model_train(images)

            loss_value_all  = 0
            &#47&#47----------------------&#47&#47
            &#47&#47   计算损失
            &#47&#47----------------------&#47&#47
            for l in range(len(outputs)):
                loss_item = yolo_loss(l, outputs[l], targets)
                loss_value_all  += loss_item
            loss_value  = loss_value_all

        val_loss += loss_value.item()
        if local_rank == 0:
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            pbar.update(1)
 
    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/yolo3-pytorch/commit/0cf1fb49d2931a04997a1972d847427bce94d736#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 10895660</div><div id='project'> Project Name: bubbliiiing/yolo3-pytorch</div><div id='commit'> Commit Name: 0cf1fb49d2931a04997a1972d847427bce94d736</div><div id='time'> Time: 2022-04-14</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(17)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 16</div><div id='m_end'> M End Line: 124</div><div id='n_start'> N Start Line: 15</div><div id='n_end'> N End Line: 127</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
    if local_rank == 0:
        print(&quotStart Train&quot)
    model_train.train()
    <a id="change">with </a><a id="change">tqdm(total=epoch_step,desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen):
            if iteration &gt;= epoch_step:
                break

            images, targets = batch[0], batch[1]
            with torch.no_grad():
                if cuda:
                    images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
                else:
                    images  = torch.from_numpy(images).type(torch.FloatTensor)
                    targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            if not fp16:
                &#47&#47----------------------&#47&#47
                &#47&#47   前向传播
                &#47&#47----------------------&#47&#47
                outputs         = model_train(images)

                loss_value_all  = 0
                &#47&#47----------------------&#47&#47
                &#47&#47   计算损失
                &#47&#47----------------------&#47&#47
                for l in range(len(outputs)):
                    loss_item = yolo_loss(l, outputs[l], targets)
                    loss_value_all  += loss_item
                loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                loss_value.backward()
                optimizer.step()
            else:
                from torch.cuda.amp import autocast
                with autocast():
                    &#47&#47----------------------&#47&#47
                    &#47&#47   前向传播
                    &#47&#47----------------------&#47&#47
                    outputs         = model_train(images)

                    loss_value_all  = 0
                    &#47&#47----------------------&#47&#47
                    &#47&#47   计算损失
                    &#47&#47----------------------&#47&#47
                    for l in range(len(outputs)):
                        loss_item = yolo_loss(l, outputs[l], targets)
                        loss_value_all  += loss_item
                    loss_value = loss_value_all

                &#47&#47----------------------&#47&#47
                &#47&#47   反向传播
                &#47&#47----------------------&#47&#47
                scaler.scale(loss_value).backward()
                scaler.step(optimizer)
                scaler.update()

            loss += loss_value.item()
            
            if local_rank == 0:
                pbar.set_postfix(**{&quotloss&quot  : loss / (iteration + 1), 
                                    &quotlr&quot    : get_lr(optimizer)})
                pbar.update(1)

    if local_rank == 0:
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)

    model_train.eval()
    <a id="change">with tqdm</a><a id="change">(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3) as pbar:
        </a>for iteration, batch in enumerate(gen_val):
            if iteration &gt;= epoch_step_val:
                break
            images, targets = batch[0], batch[1]</code></pre><h3>After Change</h3><pre><code class='java'>
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Train&quot)
        print(&quotStart Validation&quot)
        pbar = tqdm(total=epoch_step_val, desc=f&quotEpoch {epoch + 1}/{Epoch}&quot,postfix=dict,mininterval=0.3)

    model_train.eval()
    for iteration, batch in enumerate(gen_val):
        if iteration &gt;= epoch_step_val:
            break
        images, targets = batch[0], batch[1]
        with torch.no_grad():
            if cuda:
                images  = torch.from_numpy(images).type(torch.FloatTensor).cuda()
                targets = [torch.from_numpy(ann).type(torch.FloatTensor).cuda() for ann in targets]
            else:
                images  = torch.from_numpy(images).type(torch.FloatTensor)
                targets = [torch.from_numpy(ann).type(torch.FloatTensor) for ann in targets]
            &#47&#47----------------------&#47&#47
            &#47&#47   清零梯度
            &#47&#47----------------------&#47&#47
            optimizer.zero_grad()
            &#47&#47----------------------&#47&#47
            &#47&#47   前向传播
            &#47&#47----------------------&#47&#47
            outputs         = model_train(images)

            loss_value_all  = 0
            &#47&#47----------------------&#47&#47
            &#47&#47   计算损失
            &#47&#47----------------------&#47&#47
            for l in range(len(outputs)):
                loss_item = yolo_loss(l, outputs[l], targets)
                loss_value_all  += loss_item
            loss_value  = loss_value_all

        val_loss += loss_value.item()
        if local_rank == 0:
            pbar.set_postfix(**{&quotval_loss&quot: val_loss / (iteration + 1)})
            pbar.update(1)

    if local_rank == 0:
        <a id="change">pbar.close()</a>
        print(&quotFinish Validation&quot)
        loss_history.append_loss(epoch + 1, loss / epoch_step, val_loss / epoch_step_val)
        print(&quotEpoch:&quot+ str(epoch + 1) + &quot/&quot + str(Epoch))</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/bubbliiiing/yolov4-tiny-pytorch/commit/fd0007e0ce7183746c26b30c6a47d41ad49700b2#diff-1159d7fa34eff8cbe9fa807908c5121873390f54788a592aa0a1605ee5d1e0a4L9' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 10895656</div><div id='project'> Project Name: bubbliiiing/yolov4-tiny-pytorch</div><div id='commit'> Commit Name: fd0007e0ce7183746c26b30c6a47d41ad49700b2</div><div id='time'> Time: 2022-04-14</div><div id='author'> Author: 3323290568@qq.com</div><div id='file'> File Name: utils/utils_fit.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: fit_one_epoch(17)</div><div id='n_method'> N Method Name: fit_one_epoch(17)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: utils/utils_fit.py</div><div id='n_file'> N File Name: utils/utils_fit.py</div><div id='m_start'> M Start Line: 16</div><div id='m_end'> M End Line: 124</div><div id='n_start'> N Start Line: 15</div><div id='n_end'> N End Line: 126</div><BR>