<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
        divider = make_axes_locatable(plt.gca())
        ax_cb = divider.append_axes("right", size="5%", pad=0.05)
        &#47&#47 cax = self.partitioner.animate_fig.add_axes([0.9, 0, 0.05, 1])
        cmap = mpl.colors.LinearSegmentedColormap.from_list("", <a id="change">[color.hex for color in colors]</a>)
        cb1 = mpl.colorbar.ColorbarBase(ax_cb, cmap=cmap, orientation=&quotvertical&quot, label=&quott (s)&quot, values=range(len(input_constraints)))
        
        plt.gcf().add_axes(ax_cb)</code></pre><h3>After Change</h3><pre><code class='java'>

        &#47&#47 If they exist, plot all our loose input constraints (i.e., our one-step backprojection set estimates)
        &#47&#47 TODO: Make plotting these optional via a flag
        <a id="change">if </a>show_BReach:
            for info in kwargs.get(&quotper_timestep&quot, []):
                ic<a id="change"> = </a><a id="change">info.get(&quotone_step_backprojection_overapprox&quot</a>, None<a id="change">)</a>
                if ic is None: continue
                rect = ic.plot(self.partitioner.animate_axes, self.partitioner.input_dims, self.estimated_one_step_backprojection_set_color, zorder=self.estimated_one_step_backprojection_set_zorder, linewidth=self.partitioner.linewidth, plot_2d=self.partitioner.plot_2d)
                self.partitioner.default_patches<a id="change"> += </a>rect

        &#47&#47 Sketchy workaround to trajectories not showing up
        import numpy as np</code></pre>