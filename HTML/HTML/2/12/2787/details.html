<html><h3>Pattern ID :2787
</h3><img src='11144604.png'><BR><BR><BR><link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
        if verbose:
            print("keywords are unexpanded, not using")
        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
    refs = set([<a id="change">r.strip()</a> for r in refnames.strip("()").split(",")])
    &#47&#47 starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
    &#47&#47 just "foo-1.0". If we see a "tag: " prefix, prefer those.
    TAG = "tag: "
    tags = set([<a id="change">r[len(TAG) :]</a> <a id="change">for</a> <a id="change">r</a> in refs if r.startswith(TAG)])
    if not tags:
        &#47&#47 Either we&quotre using git &lt; 1.8.3, or there really are no tags. We use
        &#47&#47 a heuristic: assume all version tags have a digit. The old git %d
        &#47&#47 expansion behaves like git log --decorate=short and strips out the
        &#47&#47 refs/heads/ and refs/tags/ prefixes that would let us distinguish
        &#47&#47 between branches and tags. By ignoring refnames without digits, we
        &#47&#47 filter out many common branch names like "release" and
        &#47&#47 "stabilization", as well as "HEAD" and "master".
        tags = set([r <a id="change">for</a> r in refs if re.search(r"\d", r)])
        if verbose:
            print("discarding &quot%s&quot, no digits" % ",".join(refs - tags))
    if verbose:</code></pre><h3>After Change</h3><pre><code class='java'>
        if verbose:
            print("keywords are unexpanded, not using")
        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
    refs = {<a id="change">r.strip()</a> for r in refnames.strip("()").split(",")}
    &#47&#47 starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
    &#47&#47 just "foo-1.0". If we see a "tag: " prefix, prefer those.
    TAG = "tag: "
    tags = {<a id="change">r[len(TAG) :]</a> <a id="change">for</a> <a id="change">r</a> in refs if r.startswith(TAG)}
    if not tags:
        &#47&#47 Either we&quotre using git &lt; 1.8.3, or there really are no tags. We use
        &#47&#47 a heuristic: assume all version tags have a digit. The old git %d
        &#47&#47 expansion behaves like git log --decorate=short and strips out the
        &#47&#47 refs/heads/ and refs/tags/ prefixes that would let us distinguish
        &#47&#47 between branches and tags. By ignoring refnames without digits, we
        &#47&#47 filter out many common branch names like "release" and
        &#47&#47 "stabilization", as well as "HEAD" and "master".
        tags = {r <a id="change">for</a> r in refs if re.search(r"\d", r)}
        if verbose:
            print("discarding &quot%s&quot, no digits" % ",".join(refs - tags))
    if verbose:</code></pre><div id='inPattern'>In pattern: SUPERPATTERN</div><BR><div id='frequency'>Frequency: 3</div><BR><div id='size'>Non-data size: 12</div><BR><h3>Instances</h3><BR><div id='link'><a href='https://github.com/project-monai/monailabel/commit/6986dd936460bbe9cf6f55d0f0b4124c2958e023#diff-3d403172260e12b46eeeccbc139d0965f2113f02c4c737e682aac144e8dd8b38L186' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 11144604</div><div id='project'> Project Name: project-monai/monailabel</div><div id='commit'> Commit Name: 6986dd936460bbe9cf6f55d0f0b4124c2958e023</div><div id='time'> Time: 2022-04-11</div><div id='author'> Author: jbutler@sonovol.com</div><div id='file'> File Name: monailabel/_version.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: git_versions_from_keywords(3)</div><div id='n_method'> N Method Name: git_versions_from_keywords(3)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: monailabel/_version.py</div><div id='n_file'> N File Name: monailabel/_version.py</div><div id='m_start'> M Start Line: 186</div><div id='m_end'> M End Line: 199</div><div id='n_start'> N Start Line: 186</div><div id='n_end'> N End Line: 199</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
        if verbose:
            print("keywords are unexpanded, not using")
        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
    refs = set([<a id="change">r.strip()</a> for r in refnames.strip("()").split(",")])
    &#47&#47 starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
    &#47&#47 just "foo-1.0". If we see a "tag: " prefix, prefer those.
    TAG = "tag: "
    tags = set([<a id="change">r[len(TAG) :]</a> <a id="change">for</a> <a id="change">r</a> in refs if r.startswith(TAG)])
    if not tags:
        &#47&#47 Either we&quotre using git &lt; 1.8.3, or there really are no tags. We use
        &#47&#47 a heuristic: assume all version tags have a digit. The old git %d
        &#47&#47 expansion behaves like git log --decorate=short and strips out the
        &#47&#47 refs/heads/ and refs/tags/ prefixes that would let us distinguish
        &#47&#47 between branches and tags. By ignoring refnames without digits, we
        &#47&#47 filter out many common branch names like "release" and
        &#47&#47 "stabilization", as well as "HEAD" and "master".
        tags = set([r <a id="change">for</a> r in refs if re.search(r"\d", r)])
        if verbose:
            print("discarding &quot%s&quot, no digits" % ",".join(refs - tags))
    if verbose:</code></pre><h3>After Change</h3><pre><code class='java'>
        if verbose:
            print("keywords are unexpanded, not using")
        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
    refs = {<a id="change">r.strip()</a> for r in refnames.strip("()").split(",")}
    &#47&#47 starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
    &#47&#47 just "foo-1.0". If we see a "tag: " prefix, prefer those.
    TAG = "tag: "
    tags = {<a id="change">r[len(TAG) :]</a> <a id="change">for</a> <a id="change">r</a> in refs if r.startswith(TAG)}
    if not tags:
        &#47&#47 Either we&quotre using git &lt; 1.8.3, or there really are no tags. We use
        &#47&#47 a heuristic: assume all version tags have a digit. The old git %d
        &#47&#47 expansion behaves like git log --decorate=short and strips out the
        &#47&#47 refs/heads/ and refs/tags/ prefixes that would let us distinguish
        &#47&#47 between branches and tags. By ignoring refnames without digits, we
        &#47&#47 filter out many common branch names like "release" and
        &#47&#47 "stabilization", as well as "HEAD" and "master".
        tags = {r <a id="change">for</a> r in refs if re.search(r"\d", r)}
        if verbose:
            print("discarding &quot%s&quot, no digits" % ",".join(refs - tags))
    if verbose:</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/project-monai/monailabel/commit/ba9e89ed1dd7100e9c7b01aad344f187b2673c16#diff-3d403172260e12b46eeeccbc139d0965f2113f02c4c737e682aac144e8dd8b38L168' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 11144611</div><div id='project'> Project Name: project-monai/monailabel</div><div id='commit'> Commit Name: ba9e89ed1dd7100e9c7b01aad344f187b2673c16</div><div id='time'> Time: 2022-04-11</div><div id='author'> Author: jamesobutler@users.noreply.github.com</div><div id='file'> File Name: monailabel/_version.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: git_versions_from_keywords(3)</div><div id='n_method'> N Method Name: git_versions_from_keywords(3)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: monailabel/_version.py</div><div id='n_file'> N File Name: monailabel/_version.py</div><div id='m_start'> M Start Line: 186</div><div id='m_end'> M End Line: 199</div><div id='n_start'> N Start Line: 186</div><div id='n_end'> N End Line: 199</div><BR>'><BR><BR><BR><h3>Before Change</h3><pre><code class='java'>
        if verbose:
            print("keywords are unexpanded, not using")
        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
    refs = {<a id="change">r.strip()</a> for r in refnames.strip("()").split(",")}
    &#47&#47 starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
    &#47&#47 just "foo-1.0". If we see a "tag: " prefix, prefer those.
    TAG = "tag: "
    tags = {<a id="change">r[len(TAG) :]</a> <a id="change">for</a> <a id="change">r</a> in refs if r.startswith(TAG)}
    if not tags:
        &#47&#47 Either we&quotre using git &lt; 1.8.3, or there really are no tags. We use
        &#47&#47 a heuristic: assume all version tags have a digit. The old git %d
        &#47&#47 expansion behaves like git log --decorate=short and strips out the
        &#47&#47 refs/heads/ and refs/tags/ prefixes that would let us distinguish
        &#47&#47 between branches and tags. By ignoring refnames without digits, we
        &#47&#47 filter out many common branch names like "release" and
        &#47&#47 "stabilization", as well as "HEAD" and "master".
        tags = {r <a id="change">for</a> r in refs if re.search(r"\d", r)}
        if verbose:
            print("discarding &quot%s&quot, no digits" % ",".join(refs - tags))
    if verbose:</code></pre><h3>After Change</h3><pre><code class='java'>
        if verbose:
            print("keywords are unexpanded, not using")
        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
    refs = set([<a id="change">r.strip()</a> for r in refnames.strip("()").split(",")])
    &#47&#47 starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
    &#47&#47 just "foo-1.0". If we see a "tag: " prefix, prefer those.
    TAG = "tag: "
    tags = set([<a id="change">r[len(TAG) :]</a> <a id="change">for</a> <a id="change">r</a> in refs if r.startswith(TAG)])
    if not tags:
        &#47&#47 Either we&quotre using git &lt; 1.8.3, or there really are no tags. We use
        &#47&#47 a heuristic: assume all version tags have a digit. The old git %d
        &#47&#47 expansion behaves like git log --decorate=short and strips out the
        &#47&#47 refs/heads/ and refs/tags/ prefixes that would let us distinguish
        &#47&#47 between branches and tags. By ignoring refnames without digits, we
        &#47&#47 filter out many common branch names like "release" and
        &#47&#47 "stabilization", as well as "HEAD" and "master".
        tags = set([r <a id="change">for</a> r in refs if re.search(r"\d", r)])
        if verbose:
            print("discarding &quot%s&quot, no digits" % ",".join(refs - tags))
    if verbose:</code></pre>'><BR><BR><BR><BR><div id='link'><a href='https://github.com/project-monai/monailabel/commit/37eb5a53e426519f8041d78a68ca614f39d471fc#diff-3d403172260e12b46eeeccbc139d0965f2113f02c4c737e682aac144e8dd8b38L168' target='_blank'>Link</a></div><div id='fragmentid'> Fragment ID: 11144608</div><div id='project'> Project Name: project-monai/monailabel</div><div id='commit'> Commit Name: 37eb5a53e426519f8041d78a68ca614f39d471fc</div><div id='time'> Time: 2022-04-11</div><div id='author'> Author: jbutler@sonovol.com</div><div id='file'> File Name: monailabel/_version.py</div><div id='m_class'> M Class Name: AnonimousClass</div><div id='n_method'> N Class Name: AnonimousClass</div><div id='m_method'> M Method Name: git_versions_from_keywords(3)</div><div id='n_method'> N Method Name: git_versions_from_keywords(3)</div><div id='m_parent_class'> M Parent Class: </div><div id='n_parent_class'> N Parent Class: </div><div id='m_file'> M File Name: monailabel/_version.py</div><div id='n_file'> N File Name: monailabel/_version.py</div><div id='m_start'> M Start Line: 186</div><div id='m_end'> M End Line: 199</div><div id='n_start'> N Start Line: 186</div><div id='n_end'> N End Line: 199</div><BR>